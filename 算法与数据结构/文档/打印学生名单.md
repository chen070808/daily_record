# 综合实验一  打印选课学生名单
## 一、实验目的
1. 熟练使用链表的插入操作
2. 熟练使用排序算法
## 二、实验内容
假设全校有最多40000名学生和最多2500门课程。现给出每个学生的选课清单，要求输出每门课的选课学生名单。
## 三、实验要求
1. 输入说明:输入的第一行是两个正整数：N（≤40000），为全校学生总数；K（≤2500），为总课程数。此后N行，每行包括一个学生姓名（3个大写英文字母+1位数字）、一个正整数C（≤20）代表该生所选的课程门数、随后是C个课程编号。简单起见，课程从1到K编号。  
2. 输出说明:顺序输出课程1到K的选课学生名单。格式为：对每一门课，首先在一行中输出课程编号和选课学生总数（之间用空格分隔），之后在第二行按字典序输出学生名单，每个学生名字占一行。  
## 四、实验分析及设计
1. 问题分析（问题及解决方案）  
去除输入输出部分后，问题可分为两个部分，将学生信息存储到对应的课程中，对学生信息进行排序。对于课程的学生信息由于数据间没有明显的层序关系故使用线性表，又由于有着大量的插入操作，故使用链表。使用链表可以利用其不存储0元的特点，减少内存空间的消耗。而对于排序的时机可分为三种，先排序再插入链表，在插入链表的同时进行排序，在插入链表后（输出时）进行排序。而不同的排序时机则造成了不同的时间和空间消耗。  
对于排序时机的不同，则可以设计出三种不同的解决方案  
1）方案一：先排序再插入  
在读入并存储了全部输入以后，将学生名字按字典序排序。之后倒序处理学生记录，对每个学生i选的每门课程j，将学生i的名字插入课程j链表的表头。这样在输出时，对于每门课程j，只需要从表头输入到表尾，就自然得到按字典序正排序的名单。这个方案的缺点是需要额外空间将输入的学生信息全部存储。而在后面进行优化后会发现这个信息存储的并不会完全浪费，而只需要牺牲一点时间。优点则是其因为排序算法的优越性而有着最快的速度。  
2）方案二：插入时排序  
每读入一个学生信息，就直接将该生插入到对应课程的链表中。在插入的过程中，首先从表头向表尾扫描，找到该生姓名的合适位置，再进行插入。这种方案的优点是不需要额外的空间来存储输入的学生信息，减少了内存空间的消耗。而缺点则是在插入过程中进行排序则是相当于插入排序，插入排序的平均时间复杂度为O(n^2)与其他方案相比时间消耗比较高。  
3）方案三：插入后（输出时）排序  
每读入一个信息就直接将该生信息插入到对应课程的信息链表中，不过在插入中并不进行判断排序，直接插入，而在每一课程输出的时候进行排序，排序后输出。方案三集成了方案二的优点，或者说是改进了方案一的缺点，并不需要将所有输入的学生信息存入内存，而是读取后直接插入。同时也对方案二的缺点进行了改进，在插入时放弃效率较低插入排序，而只是简单插入，在输出的时候使用效率更高的其他排序。而在后面的优化中会发现，方案三有着与方案二相近的空间消耗，却有着与方案一相差不多的时间消耗。

2. 概要设计（实现要点）  
数据存储实现：  
对于学生信息，仅有方案一对其需要存储，为了方便查找读取这里使用顺序表来存储，为了程序简化，仅仅定义了数组，而没有做严格的封装。而且使用数组存储学生信息的话，可以在仅增加常数级的时间的操作来减少存储空间的消耗。由于题目仅要求输出学生姓名，因此课程信息可以存储学生姓名，也可以因为学生信息存为顺序表而存储学生表中的序号，将五个字符的存储空间减少了整数型的存储空间，仅仅增加数组的查找操作时间，而这个时间是较少的。对于其他方案，在获得学生信息后就直接插入到对应的课程表中，因此不需要专门的学生信息表，而只需要一个学生信息结构体来存储当前学生信息。  
对于课程，设立课程表来存储不同的课程，对于课程表由于没有插入操作和随机查找操作，因此使用顺序表还是链表都是可以的，在这里为了编写方便使用了数组存储，而没有严格的封装为顺序表。  
对于课程信息，因为有着大量的插入操作，如果和课程表一同建立二维数组会有着大量空间的浪费，因此使用链表来存储课程信息，即选择当前课程的学生信息。  
排序操作：  
	对于方案一，排序针对的是学生信息，由于学生信息使用顺序表实现，对于各种排序算法都可使用，在这里使用时间和空间效率都较高的快速排序算法,时间复杂度为$O(nlogn)$，空间为$O(logn)$。  
	对于方案二，排序出现在插入的过程，因此只能单一的使用插入排序算法，时间复杂度为$O(n^2)$，空间为$O(1)$。  
	对于方案三，排序针对的是单链表，可选的排序算法有很多，这里为了减少内存的消耗使用自底向上非递归形式的归并排序算法，在O(1)的空间消耗中有着$O(nlogn)$时间复杂度。

3. 详细设计   
1）数据类型定义  
由后面的算法性能分析我们会发现实际上方案三具有着比方案二更低的时间复杂度以及相似的空间消耗，因此后面仅实现方案一与方案三。

方案一;
学生信息结构体，包含学生姓名，学生选课数量，学生所选课编号。
```C++
typedef struct student
{
    char name[5];
    int num;
    int choice[20];
}student;
```
课程信息结构体，data数据头结点存储该课程学生总数，其余结点存储学生编号。
```C++
typedef struct course
{
    int data;
    struct course* next;
}course;
```
方案三：
学生信息结构体，包含学生姓名，学生选课数量，学生所选课编号。
```C++
typedef struct student
{
    char name[5];
    int num;
    int choice[20];
}student;
```
课程结构体包含该课程学生总数以及课程信息指针。
```C++
typedef struct course
{
    int data;
    struct node* next;
}course;
```
课程信息包含学生姓名和下一节点指针。
```C++
typedef struct node
{
    char name[5];
    struct node* next;
}node;
```
2）算法设计
方案一：
首先是输入，首先读入n和k，建立大小为n个学生的学生信息表，初始化并建立k个课程信息表。  
之后依次读入n个学生信息存入学生信息表。  
通过快速排序将学生信息排序。快速排序通过设立两个变量ij记数，各自从前从后移动，将tmp放置到对应位置，之后递归的将之前之后数据进行快速排序。快速排序需要对边界注意，high和low应输入为第一个和最后一个有数据的位置。大小判断使用string中的库函数strcmp获得字典序的判断。  
之后将学生数据从后向前使用头插法插入到对应是课程信息中，因为头插法相对于尾插法有着更高的效率，之后通过逆序的进行插入，则可以在输出的时候获得顺序信息。而且这里的插入并不是直接将学生信息插入，而是仅仅在data中插入学生信息标号，更加充分的利用了已有存储空间，而且在如果题目要求输出学生其他信息时会有着更大的优势。并且将数据类型统一为了整型。头结点的整型数据意义为选课学生总数，后继节点为学生信息在学生信息表中的位置，在插入操作后将头结点信息更新。  
输出则是简单的将所有课程信息链表遍历输出，不过由于数据课程信息存储的是学生信息在顺序表中的位置，需要消耗O(1)的时间来获取。  

方案三：
首先是与方案一相同的输入，读入n和k，建立大小为n个学生的学生信息表，初始化并建立k个课程信息表。
之后是读取学生信息，创建结点并将其插入到对应的课程信息表中。
之后是遍历课程表，对每一个课程信息进行排序后输出。这里优化为迭代的归并排序，从而将空间复杂度从O(n)降到O(1)
自顶向下递归形式的归并排序，由于递归需要使用系统栈，递归的最大深度是 logn，所以需要额外 O(logn)的空间。
所以我们需要使用自底向上非递归形式的归并排序算法。
基本思路是这样的，总共迭代logn次：
第一次，将整个区间分成连续的若干段，每段长度是2：$[a0,a1],[a2,a3],…[an−1,an−1][a0,a1],[a2,a3],…[an−1,an−1]$， 然后将每一段内排好序，小数在前，大数在后；
第二次，将整个区间分成连续的若干段，每段长度是4：$[a0,…,a3],[a4,…,a7],…[an−4,…,an−1][a0,…,a3],[a4,…,a7],…[an−4,…,an−1]$，然后将每一段内排好序，这次排序可以利用之前的结果，相当于将左右两个有序的半区间合并，可以通过一次线性扫描来完成；
依此类推，直到每段小区间的长度大于等于n为止；
另外，当n不是2的整次幂时，每次迭代只有最后一个区间会比较特殊，长度会小一些，遍历到指针为空时需要提前结束。
之后对课程信息表进行遍历输出。


## 五、实验测试结果（至少两种测试数据）

测试输入一（课程2 无人选）：
5 3  
ZOE1 2 1 3  
ANN0 2 1 3  
BOB5 1 1  
JOE4 1 3  
JAY9 1 1  

测试输入二（一般情况）：
10 5  
ZOE1 2 4 5  
ANN0 3 5 2 1  
BOB5 5 3 4 2 1 5  
JOE4 1 2  
JAY9 4 1 2 5 4  
FRA8 3 4 2 5  
DON2 2 4 5  
AMY7 1 5  
KAT3 3 5 4 2  
LOR6 4 2 4 1 5  

方案三：

测试输入一（课程2 无人选）：
5 3  
ZOE1 2 1 3  
ANN0 2 1 3  
BOB5 1 1  
JOE4 1 3  
JAY9 1 1  


测试输入二（一般情况）：
10 5  
ZOE1 2 4 5  
ANN0 3 5 2 1  
BOB5 5 3 4 2 1 5  
JOE4 1 2  
JAY9 4 1 2 5 4  
FRA8 3 4 2 5  
DON2 2 4 5  
AMY7 1 5  
KAT3 3 5 4 2  
LOR6 4 2 4 1 5  

## 六、实验分析与总结
1、算法性能分析   
方案一：  
时间：  
首先是读入数据O(n)n个数据的读入存储,之后对学生数据进行排序（快速排序）平均为$O(nlogn)$,之后是插入$O(MaxC*n)$,输出$O(MaxC*n)$。总体为$O(n)+O(nlogn)+ O(MaxC*n)+ O(MaxC*n)$。为$O(nlogn)$  
空间：  
学生信息的存储$O(n)$，课程信息存储$O(MaxC*n)$，不过快速排序使用递归方法有$logn$深度的递归有额外的$O(logn)$的消耗。

方案二：  
时间：  
读入插入$O(K*n2)$,输出$O(MaxC*n)$。总体为$O(K*n^2)+ O(MaxC*n)$。为$O(n^2)$。当然实际情况中如果一个课程的最大学生容量为$m$（实际上$m \ll n$）则读入插入的时间复杂度为$O(K*m^2)$。  
空间：  
学生信息的临时存储$O(1)$，课程信息存储$O(MaxC*n)$。  

方案三：  
时间：  
读入插入$O(MaxC*n)$,归并排序$O(MaxC*nlogn)$，输出$O(MaxC*n)$。总体为$O(MaxC*n)+ O(MaxC*nlogn)+ O(MaxC*n)$，为$O(nlogn)$。与方案二相似，实际情况中如果一个课程的最大学生容量为$m$（实际上$m \ll n$）则排序的时间复杂度为$O(K*mlogm)$。  
空间：  
学生信息的临时存储$O(1)$，归并排序临时变量$O(1)$,课程信息存储$O(MaxC*n)$。  
通过上面的分析可以发现方案一和三有着相同的时间复杂度而方案二的效率较低时间复杂度为$O(n2)$，并且方案二和方案三的空间消耗相同数量级。因此在时空复杂度的综合上方案三要优于方案一和二

2、思考与总结  
对于方案一和方案二哪种方案是最好的，就相当于在思考时间消耗和空间消耗上究竟哪一个更重要。对于方案一和二的区别中，方案一牺牲了空间，来使用时间效率更高的排序方法而对于方案二则是尽量减少空间消耗，而在插入的同时进行排序。对于大多数像pta的oj平台在提交时更多的限制的是时间复杂度，而对于空间开销限制不严，也就造成了方案二无法通过大数据测试而方案一可以通过。不过这并不能体现时间一定比空间重要，对于云服务主机等大量数据存放时，内存也可能会成为系统服务的瓶颈。  
时间复杂度和空间复杂度有直接关系吗，其实不然。在通常情况下，放弃两者之一，能加速另外一侧，但是不强相关。  
通过本次综合实验让我更好的理解了线性表的定义与使用，也更深入的理解了线性表和链表的区别。在实验中认识到了不同算法的时空复杂度分析以及优化取舍。也学习到了不同的排序算法的优势与改进。在程序编写中也认识到了问题分析与调试的重要性。加深了对数据结构与算法这门课程的理解。  


七、 实验参考代码（含注释）

方案一：
```C++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct student
{
    char name[5];
    int num;
    int choice[20];
}student;
typedef struct course
{
    int data;
    struct course* next;
}course;

void sort(student* stu, int low, int high);
void insert(student* stu, course** cou, int n, int k);
void out(student* stu, course** cou, int k);

int main()
{
    int n, k;
    scanf("%d%d", &n, &k);
    student* stu = (student*)malloc(sizeof(student) * n);
    course** cou = (course**)malloc(sizeof(course*) * k);
    for (int i = 1; i <= k; i++)
    {
        cou[i] = (course*)malloc(sizeof(course));
        cou[i]->data = 0;
        cou[i]->next = NULL;
    }
    //输入
    for (int i = 0; i < n; i++)
    {
        scanf("%s", stu[i].name);
        scanf("%d", &stu[i].num);
        for (int j = 0; j < stu[i].num; j++)
        {
            scanf("%d", &stu[i].choice[j]);
        }
    }
    //排序
    sort(stu, 0, n - 1);
    //插入
    insert(stu, cou, n, k);
    //输出
    out(stu, cou, k);
    return 0;
}

//快速排序
void sort(student* stu, int low, int high) {
    if (low < high)
    {
        student tmp;
        int i = low, j = high;
        tmp = stu[low];
        while (i < j)
        {
            //从后向前
            while (i < j && strcmp((&tmp)->name, (&stu[j])->name) <= 0)
                --j;
            if (i < j) {
                stu[i] = stu[j];
                ++i;
            }
            //从前向后
            while (i < j && strcmp((&tmp)->name, (&stu[i])->name) >0)
                ++i;
            if (i < j) {
                stu[j] = stu[i];
                --j;
            }
        }
        stu[i] = tmp;
        sort(stu, low, i - 1);
        sort(stu, i + 1, high);
    }
}

//带头结点的头插法
void insert(student* stu, course** cou, int n, int k)
{
    for (int i = n - 1; i >= 0; i--)
    {
        for (int j = stu[i].num - 1; j >= 0; j--)
        {
            course* p = (course*)malloc(sizeof(course));
            p->data = i;
            p->next = cou[stu[i].choice[j]]->next;
            cou[stu[i].choice[j]]->data++;
            cou[stu[i].choice[j]]->next = p;
        }
    }
}


//遍历课程表中课程信息输出
void out(student* stu, course** cou, int k)
{
    for (int i = 1; i <= k; i++)
    {
        course* out = cou[i];
        printf("%d %d\n", i, out->data);
        out = out->next;
        while (out)
        {
            printf("%s\n", stu[out->data].name);
            out = out->next;
        }
    }
}
```

方案三：
```C++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct student
{
    char name[5];
    int num;
    int choice[20];
}student;
typedef struct course
{
    int data;
    struct node* next;
}course;

typedef struct node
{
    char name[5];
    struct node* next;
}node;

void insert(course**& cou, int n, int k);
node* sortList(node* head);
void out(course** cou, int k);

int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    course** cou = (course**)malloc(sizeof(course*) * n);
    for (int i = 1; i <= k; i++)
    {
        cou[i] = (course*)malloc(sizeof(course));
        cou[i]->data = 0;
        cou[i]->next = NULL;
    }
    insert(cou, n, k);
    out(cou, k);
    return 0;
}

//头插法
void insert(course**& cou, int n, int k)
{
    student stu;
    for (int i = 0; i < n; i++)
    {
        scanf("%s", stu.name);
        scanf("%d", &stu.num);
        for (int j = 0; j < stu.num; j++)
        {
            scanf("%d", &stu.choice[j]);
            node* p = (node*)malloc(sizeof(node));
            strcpy(p->name, stu.name);
            p->next = cou[stu.choice[j]]->next;
            cou[stu.choice[j]]->data++;
            cou[stu.choice[j]]->next = p;
        }
    }
}

//将链表排序为有序，返回链表头结点
node* sortList(node* head) {
    int n = 0;
    for (node* p = head; p; p = p->next) n++;

    node* dummy = (node*)malloc(sizeof(node));
    dummy->next = head;
    for (int i = 1; i < n; i *= 2)
    {
        node* begin = dummy;
        //遍历每一段
        for (int j = 0; j + i < n; j += i * 2)
        {
            node* first = begin->next, * second = first;
            for (int k = 0; k < i; k++)
                second = second->next;
            int f = 0, s = 0;
            while (f < i && s < i && second)
                if (strcmp(first->name,second->name)<0)
                {
                    begin = begin->next = first;
                    first = first->next;
                    f++;
                }
                else
                {
                    begin = begin->next = second;
                    second = second->next;
                    s++;
                }
            //归并
            while (f < i)
            {
                begin = begin->next = first;
                first = first->next;
                f++;
            }
            while (s < i && second)
            {
                begin = begin->next = second;
                second = second->next;
                s++;
            }

            begin->next = second;
        }
    }

    return dummy->next;
}

//输出
void out(course** cou, int k)
{
    for (int i = 1; i <= k; i++)
    {
        printf("%d %d\n", i, cou[i]->data);
        node* out = cou[i]->next;
        if (out) {
            out=sortList(out);
            while (out)
            {
                printf("%s\n", out->name);
                out = out->next;
            }
        }
    }
} 
```
